import{_ as s,c as l,a2 as a,o as n}from"./chunks/framework.CDk703ml.js";const o=JSON.parse('{"title":"HTTP 网络请求","description":"","frontmatter":{},"headers":[],"relativePath":"docs/first-exam/HTTP.md","filePath":"docs/first-exam/HTTP.md"}'),t={name:"docs/first-exam/HTTP.md"};function e(p,i,h,k,r,E){return n(),l("div",null,i[0]||(i[0]=[a(`<h1 id="http-网络请求" tabindex="-1">HTTP 网络请求 <a class="header-anchor" href="#http-网络请求" aria-label="Permalink to &quot;HTTP 网络请求&quot;">​</a></h1><p>HTTP 和 Ajax 是前后端沟通的桥梁，面试重点考察，无论工作经验长短。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如有疑问，可免费 <a href="/mianshi/docs/services/group.html">加群</a> 讨论咨询，也可参与 <a href="/mianshi/docs/services/1v1.html">1v1 面试咨询服务</a>， 专业、系统、高效、全流程 准备前端面试</p></div><h2 id="tcp-是如何建立连接的-三次握手-四次挥手" tabindex="-1">TCP 是如何建立连接的，三次握手，四次挥手 <a class="header-anchor" href="#tcp-是如何建立连接的-三次握手-四次挥手" aria-label="Permalink to &quot;TCP 是如何建立连接的，三次握手，四次挥手&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>三次握手</p><ul><li>客户端向服务端发送建立连接请求，客户端进入 SYN-SEND 状态</li><li>服务端收到建立连接请求后，向客户端发送一个应答，服务端进入 SYN-RECEIVED 状态</li><li>客户端接收到应答后，向服务端发送确认接收到应答，客户端进入 ESTABLISHED 状态</li></ul><p>四次挥手</p><ul><li>客户端向服务端发送断开连接请求</li><li>服务端收到断开连接请求后，告诉应用层去释放 tcp 连接</li><li>服务端向客户端发送最后一个数据包 FINBIT ，服务端进入 LAST-ACK 状态</li><li>客户端收到服务端的断开连接请求后，向服务端确认应答</li></ul><blockquote><p>三次握手四次挥手，客户端都是主动方，服务端都是被动方。在状态方面：三次握手的客户端和服务端都是由原来的 closed 变为 established，四次挥手的客户端和服务端都是由原来的 established 变为 closed。</p></blockquote></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7350107540327022601" target="_blank" rel="noreferrer">https://juejin.cn/post/7350107540327022601</a></li></ul></details><h2 id="http-几个版本的区别" tabindex="-1">HTTP 几个版本的区别 <a class="header-anchor" href="#http-几个版本的区别" aria-label="Permalink to &quot;HTTP 几个版本的区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><h4 id="http-0-9-单行协议" tabindex="-1">HTTP/0.9 - 单行协议 <a class="header-anchor" href="#http-0-9-单行协议" aria-label="Permalink to &quot;HTTP/0.9 - 单行协议&quot;">​</a></h4><ul><li>只有 GET 请求行，无请求头和请求体</li><li>只能传输 HTML 文件，以 ASCII 字符流返回</li><li>无响应头</li></ul><h4 id="http-1-0-多类型支持" tabindex="-1">HTTP/1.0 - 多类型支持 <a class="header-anchor" href="#http-1-0-多类型支持" aria-label="Permalink to &quot;HTTP/1.0 - 多类型支持&quot;">​</a></h4><ul><li>支持多种文件类型传输，不限于 ASCII 编码</li><li>引入请求头和响应头( key-value 形式)</li><li>每个请求都需要建立新的 TCP 连接</li></ul><h4 id="http-1-1-持久连接" tabindex="-1">HTTP/1.1 - 持久连接 <a class="header-anchor" href="#http-1-1-持久连接" aria-label="Permalink to &quot;HTTP/1.1 - 持久连接&quot;">​</a></h4><ul><li>引入持久连接( keep-alive )：一个 TCP 连接可传输多个 HTTP 请求</li><li>默认开启 keep-alive，通常限制 6-8 个并发连接</li><li>存在队头阻塞问题：前面的请求阻塞会影响后续请求</li><li>引入 Host 字段，支持虚拟主机</li><li>引入 Chunk transfer 机制处理动态内容长度</li></ul><h4 id="http-2-0-多路复用" tabindex="-1">HTTP/2.0 - 多路复用 <a class="header-anchor" href="#http-2-0-多路复用" aria-label="Permalink to &quot;HTTP/2.0 - 多路复用&quot;">​</a></h4><ul><li>一个域名只使用一个 TCP 长连接</li><li>引入二进制分帧层，实现多路复用</li><li>可对请求设置优先级</li><li>引入 HTTPS(HTTP + TLS) 加密</li></ul><h4 id="http-3-0-quic-协议" tabindex="-1">HTTP/3.0 - QUIC 协议 <a class="header-anchor" href="#http-3-0-quic-协议" aria-label="Permalink to &quot;HTTP/3.0 - QUIC 协议&quot;">​</a></h4><ul><li>基于 UDP 协议而非 TCP</li><li>实现了类似 TCP 的流量控制和可靠传输</li><li>集成 TLS 加密</li><li>实现多路复用</li><li>解决 TCP 队头阻塞问题</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7350520171611652147" target="_blank" rel="noreferrer">https://juejin.cn/post/7350520171611652147</a></li></ul></details><h2 id="http-常见的状态码" tabindex="-1">HTTP 常见的状态码 <a class="header-anchor" href="#http-常见的状态码" aria-label="Permalink to &quot;HTTP 常见的状态码&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ul><li>200 请求成功，请求在服务端被正确处理</li><li>204 响应成功，没有数据</li><li>205 服务器处理成功，浏览器应重置文档视图</li><li>206 服务器成功处理了部分get请求</li><li>301 资源永久重定向</li><li>302 资源临时重定向</li><li>303 让你查看其他地址</li><li>304 请求的资源没有修改，服务端不会返回任何资源，协商缓存</li><li>400 请求语法错误，服务器看不懂</li><li>401 请求没有携带信息，比如 token 认证失败</li><li>403 请求被拒绝、敏感词</li><li>404 找不到资源</li><li>500 服务器内部错误，无法完成请求</li><li>501 服务器不支持当前请求所需的功能</li><li>503 服务器系统维护或者超载，暂时无法处理客户端的请求</li></ul></details><h2 id="http-常见-header" tabindex="-1">HTTP 常见 Header <a class="header-anchor" href="#http-常见-header" aria-label="Permalink to &quot;HTTP 常见 Header&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>请求头</p><ul><li>accept: text/html 告诉服务端我期望接收到一个html的文件</li><li>accept-encoding: gzip, deflate, br 告诉服务端以这种方式压缩</li><li>accept-language: zh-CN 告诉服务端以中文的格式返回</li><li>authorization: 告诉服务端授权信息</li><li>cookie: 告诉服务端客户端存储的 cookie</li><li>origin: 告诉服务端请求的来源</li></ul><p>响应头</p><ul><li>content-encoding: br 告诉浏览器压缩方式是br</li><li>content-type: text/html; charset=utf-8 告诉浏览器以这种方式，编码加载</li><li>cache-control: 告诉浏览器缓存策略</li><li>expires: 告诉浏览器缓存过期时间</li><li>set-cookie: 告诉浏览器设置 cookie</li><li>access-control-allow-origin: * 告诉浏览器允许跨域</li></ul></details><h2 id="url-包含哪些部分" tabindex="-1">URL 包含哪些部分？ <a class="header-anchor" href="#url-包含哪些部分" aria-label="Permalink to &quot;URL 包含哪些部分？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>URL (Uniform Resource Locator) 包含以下部分：</p><ol><li><p>协议 (protocol)：如 <code>http://</code>、<code>https://</code>、<code>ftp://</code> 等</p></li><li><p>域名 (domain)：如 <code>www.example.com</code></p><ul><li>子域名：<code>www</code></li><li>主域名：<code>example</code></li><li>顶级域名：<code>com</code></li></ul></li><li><p>端口号 (port)：如 <code>:80</code>、<code>:443</code>（可选，HTTP 默认 80，HTTPS 默认 443）</p></li><li><p>路径 (path)：如 <code>/blog/article</code></p></li><li><p>查询参数 (query string)：如 <code>?id=123&amp;name=test</code></p></li><li><p>锚点/片段标识符 (fragment)：如 <code>#header</code></p></li></ol><p>示例：<a href="https://www.example.com:80/blog/article?id=123&amp;name=test#header" target="_blank" rel="noreferrer">https://www.example.com:80/blog/article?id=123&amp;name=test#header</a></p></details><h2 id="get-和-post-请求的区别" tabindex="-1">GET 和 POST 请求的区别 <a class="header-anchor" href="#get-和-post-请求的区别" aria-label="Permalink to &quot;GET 和 POST 请求的区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ul><li>协议层面：请求行里一定要有请求方法，官方为了统一语义，定义了 GET 表示拿数据，POST 表示上传数据，PUT 表示修改数据，所以 GET，POST 请求这里仅仅是语义上的差别，没有说哪个请求必须做啥</li><li>应用层面：开发者约定俗成的规范，GET 请求的请求体会设空，不是没有请求体</li><li>浏览器层面：GET 请求会缓存，有历史记录</li></ul></details><h2 id="ajax-fetch-axios-三者有什么区别" tabindex="-1">Ajax Fetch Axios 三者有什么区别？ <a class="header-anchor" href="#ajax-fetch-axios-三者有什么区别" aria-label="Permalink to &quot;Ajax Fetch Axios 三者有什么区别？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>Ajax、Fetch 和 Axios 都是用于发送 HTTP 请求的技术，但有以下区别：</p><p>Ajax (Asynchronous JavaScript and XML)</p><ul><li>是一种技术统称，不是具体的 API</li><li>最常用的实现是 XMLHttpRequest (XHR)</li><li>写法比较繁琐，需要手动处理各种状态</li><li>回调地狱问题</li><li>不支持 Promise</li></ul><p>Fetch</p><ul><li>浏览器原生 API</li><li>基于 Promise</li><li>更简洁的写法</li><li>不需要额外引入</li><li>只对网络请求报错，对 400、500 都当做成功的请求</li><li>默认不带 cookie</li><li>不支持请求超时控制</li><li>不支持请求取消</li><li>不支持请求进度监控</li></ul><p>Axios</p><ul><li>第三方库，需要额外引入</li><li>基于 Promise</li><li>支持浏览器和 Node.js</li><li>请求/响应拦截器</li><li>自动转换 JSON 数据</li><li>客户端支持防止 XSRF</li><li>支持请求取消</li><li>支持请求超时控制</li><li>支持请求进度监控</li><li>支持并发请求</li><li>自动转换请求和响应数据</li></ul><p>使用建议：</p><ul><li>如果是简单的请求，使用 Fetch 即可</li><li>如果需要更多功能，建议使用 Axios</li><li>现代项目中已经很少直接使用 XMLHttpRequest</li></ul></details><h2 id="fetch-和-xmlhttprequest-有什么区别" tabindex="-1">Fetch 和 XMLHTTPRequest 有什么区别？ <a class="header-anchor" href="#fetch-和-xmlhttprequest-有什么区别" aria-label="Permalink to &quot;Fetch 和 XMLHTTPRequest 有什么区别？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>语法和使用</p><ul><li>Fetch 基于 Promise，代码更简洁优雅</li><li>XHR 使用回调函数，容易产生回调地狱</li><li>Fetch 的 API 设计更简单现代</li><li>XHR 的 API 设计较老，使用相对复杂</li></ul><p>功能特性</p><ul><li>Fetch 默认不发送 cookies，需要配置 credentials</li><li>XHR 默认发送 cookies</li><li>Fetch 不能监听上传进度</li><li>XHR 可以监听上传和下载进度</li><li>Fetch 不能直接取消请求（需要 AbortController）</li><li>XHR 可以通过 abort() 直接取消请求</li></ul><p>错误处理</p><ul><li>Fetch 只有网络错误才会 reject，HTTP 错误码不会导致 reject</li><li>XHR 可以处理所有类型的错误，包括 HTTP 错误码</li></ul><p>浏览器支持</p><ul><li>Fetch 是现代浏览器标准 API</li><li>XHR 有更好的浏览器兼容性，包括旧版本</li></ul></details><h2 id="什么是-restful-api" tabindex="-1">什么是 Restful API ？ <a class="header-anchor" href="#什么是-restful-api" aria-label="Permalink to &quot;什么是 Restful API ？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>RESTful API 是一种软件架构风格，用于设计网络应用程序的接口。主要特点：</p><p>资源导向</p><ul><li>使用 URL 定位资源</li><li>每个资源都有唯一的 URL</li><li>资源可以有多种表现形式（如 JSON、XML）</li></ul><p>HTTP 方法对应操作</p><ul><li>GET：获取资源</li><li>POST：创建资源</li><li>PUT：更新资源（完整更新）</li><li>PATCH：更新资源（部分更新）</li><li>DELETE：删除资源</li></ul><p>无状态</p><ul><li>服务器不保存客户端状态</li><li>每个请求包含所需的所有信息</li><li>有利于横向扩展</li></ul><p>统一接口</p><ul><li>使用标准的 HTTP 方法</li><li>使用标准的 HTTP 状态码</li><li>返回格式一致（通常是 JSON）</li></ul></details><h2 id="什么是-graphql" tabindex="-1">什么是 GraphQL ？ <a class="header-anchor" href="#什么是-graphql" aria-label="Permalink to &quot;什么是 GraphQL ？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>GraphQL 是一种用于 API 的查询语言和运行时，由 Facebook 开发。主要特点：</p><p>查询灵活性</p><ul><li>客户端可以精确指定需要哪些数据</li><li>可以在一个请求中获取多个资源</li><li>避免了传统 REST API 的过度获取和获取不足问题</li></ul><p>类型系统</p><ul><li>强类型的 Schema 定义</li><li>自动生成文档</li><li>开发时有更好的类型提示</li></ul><p>单个端点</p><ul><li>只需要一个 API 端点</li><li>所有查询都发送到同一个地址</li><li>通过查询语句区分不同的操作</li></ul><p>主要操作类型</p><ul><li>Query：获取数据</li><li>Mutation：修改数据</li><li>Subscription：实时数据订阅</li></ul><p>优点</p><ul><li>减少网络请求</li><li>避免版本化问题</li><li>强类型保障</li><li>更好的开发体验</li></ul><p>缺点</p><ul><li>学习成本较高</li><li>缓存较为复杂</li><li>服务端实现复杂度增加</li></ul></details><h2 id="如何理解-cookie" tabindex="-1">如何理解 cookie <a class="header-anchor" href="#如何理解-cookie" aria-label="Permalink to &quot;如何理解 cookie&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据。</p><p>主要特点：</p><ul><li>由服务器生成，浏览器进行存储</li><li>每次请求时会自动携带对应域名下的 cookie</li><li>可设置过期时间</li><li>默认情况下随着浏览器关闭而删除（会话 cookie）</li></ul><p>常用属性：</p><ul><li>name：cookie 名称</li><li>value：cookie 值</li><li>domain：指定 cookie 所属域名</li><li>path：指定 cookie 所属路径</li><li>expires/max-age：过期时间</li><li>secure：只在 HTTPS 下传输</li><li>httpOnly：禁止 JS 访问</li><li>sameSite：跨站点请求限制</li></ul><p>使用场景：</p><ul><li>会话状态管理（用户登录状态、购物车等）</li><li>个性化设置（用户偏好、主题等）</li><li>浏览器行为跟踪（分析用户行为等）</li></ul><p>限制：</p><ul><li>大小限制：通常为 4KB</li><li>数量限制：每个域名下的 cookie 数量有限</li><li>安全性：明文传输（除非使用 HTTPS）</li><li>作用域：只能在所属域名下使用</li></ul></details><h2 id="为何现代浏览器都禁用第三方-cookie" tabindex="-1">为何现代浏览器都禁用第三方 cookie <a class="header-anchor" href="#为何现代浏览器都禁用第三方-cookie" aria-label="Permalink to &quot;为何现代浏览器都禁用第三方 cookie&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>主要原因是保护用户隐私和安全：</p><p>隐私问题</p><ul><li>第三方 Cookie 可以跨站点追踪用户行为</li><li>广告商可以构建用户画像和浏览历史</li><li>用户数据可能被未经授权收集和使用</li></ul><p>安全风险</p><ul><li>增加 CSRF（跨站请求伪造）攻击风险</li><li>可能被用于会话劫持</li><li>恶意网站可能滥用第三方 Cookie</li></ul><p>技术影响</p><ul><li>Safari 和 Firefox 已默认禁用第三方 Cookie</li><li>Chrome 计划在 2024 年完全禁用第三方 Cookie</li><li>替代方案： <ul><li>First-Party Cookie</li><li>localStorage</li><li>Privacy Sandbox</li><li>FLoC (Federated Learning of Cohorts)</li></ul></li></ul></details><h2 id="如何理解-session" tabindex="-1">如何理解 Session ？ <a class="header-anchor" href="#如何理解-session" aria-label="Permalink to &quot;如何理解 Session ？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>Session 是服务器端的会话管理机制：</p><p>基本概念</p><ul><li>服务器为每个用户创建的临时会话存储空间</li><li>用于保存用户的会话状态</li><li>通过 SessionID 来识别不同用户</li><li>SessionID 通常保存在 Cookie 中</li></ul><p>工作流程</p><ol><li>用户首次访问服务器时，服务器创建 Session 并生成 SessionID</li><li>服务器将 SessionID 通过 Cookie 发送给客户端</li><li>客户端后续请求会自动携带包含 SessionID 的 Cookie</li><li>服务器通过 SessionID 找到对应 Session 并识别用户</li></ol><p>特点</p><ul><li>安全性较高：敏感数据存储在服务器</li><li>服务器负载较大：需要存储所有用户的 Session</li><li>依赖 Cookie：通常需要 Cookie 来存储 SessionID</li><li>集群问题：需要考虑 Session 共享</li></ul><p>使用场景</p><ul><li>用户登录状态管理</li><li>购物车</li><li>权限验证</li><li>表单验证</li></ul><p>与 Cookie 的区别</p><ul><li>存储位置：Session 在服务器，Cookie 在客户端</li><li>安全性：Session 较安全，Cookie 相对不安全</li><li>存储容量：Session 容量较大，Cookie 通常限制 4KB</li><li>性能：Session 消耗服务器资源，Cookie 消耗带宽资源</li></ul></details><h2 id="什么是-jwt-描述它的工作过程" tabindex="-1">什么是 JWT 描述它的工作过程 <a class="header-anchor" href="#什么是-jwt-描述它的工作过程" aria-label="Permalink to &quot;什么是 JWT 描述它的工作过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>JWT (JSON Web Token) 是一种开放标准，用于在各方之间安全地传输信息。</p><p>组成部分（用 . 分隔的三部分）：</p><ul><li>Header（头部）：指定加密算法和令牌类型</li><li>Payload（负载）：包含声明（claims）的实际数据</li><li>Signature（签名）：对前两部分的签名，用于验证消息未被篡改</li></ul><p>工作流程：</p><ol><li><p>用户登录成功后，服务器创建 JWT</p><ul><li>设置 Header 和 Payload</li><li>使用密钥生成签名</li><li>将三部分组合成 token</li></ul></li><li><p>服务器将 token 返回给客户端</p><ul><li>客户端存储在 localStorage 或 cookie 中</li></ul></li><li><p>后续请求携带 token</p><ul><li>通常放在 Authorization header</li><li>格式：<code>Bearer &lt;token&gt;</code></li></ul></li><li><p>服务器验证 token</p><ul><li>检查签名是否有效</li><li>验证是否过期</li><li>验证其他声明（claims）</li></ul></li></ol><p>特点：</p><ul><li>无状态：服务器不需要存储会话信息</li><li>可扩展：负载部分可以包含自定义数据</li><li>跨域友好：可以在不同域名下使用</li><li>性能好：验证在服务端完成，不需要查询数据库</li></ul><p>安全考虑：</p><ul><li>不要在 payload 中存储敏感信息</li><li>设置合理的过期时间</li><li>使用 HTTPS 传输</li><li>妥善保管签名密钥</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7346430299490189348" target="_blank" rel="noreferrer">https://juejin.cn/post/7346430299490189348</a></li></ul></details><h2 id="jwt-如何自动更新-token" tabindex="-1">JWT 如何自动更新 token ？ <a class="header-anchor" href="#jwt-如何自动更新-token" aria-label="Permalink to &quot;JWT 如何自动更新 token ？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>JWT token 自动更新主要有以下几种方案：</p><p>双 token 机制</p><ul><li>access token：短期令牌，用于接口认证</li><li>refresh token：长期令牌，用于刷新 access token</li><li>优点：安全性高，即使 access token 泄露影响有限</li><li>缺点：实现相对复杂，需要额外存储 refresh token</li></ul><p>工作流程：</p><ol><li>用户登录后获取 access token 和 refresh token</li><li>使用 access token 访问接口</li><li>access token 过期时，使用 refresh token 获取新的 access token</li><li>refresh token 过期时，需要重新登录</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前端示例代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      headers: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Authorization: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Bearer \${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAccessToken</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (res.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 401</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // access token 过期，尝试刷新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newToken</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> refreshToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newToken) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 使用新 token 重试请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // refresh token 也过期，跳转登录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        redirectToLogin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>滑动过期机制</p><ul><li>每次请求都刷新 token 过期时间</li><li>类似于会话超时机制</li><li>优点：实现简单，用户体验好</li><li>缺点：安全性相对较低</li></ul><p>无感刷新机制</p><ul><li>在 token 即将过期时自动刷新</li><li>可以通过定时器或请求拦截器实现</li><li>优点：用户无感知，体验好</li><li>缺点：需要处理并发请求的问题</li></ul><p>最佳实践：</p><ul><li>根据业务安全需求选择合适的方案</li><li>access token 过期时间不宜过长（如 2 小时）</li><li>refresh token 过期时间可以较长（如 7 天）</li><li>重要操作仍需要二次验证</li><li>考虑 token 注销机制</li></ul></details><h2 id="什么是-sso-单点登录-描述它的工作过程" tabindex="-1">什么是 SSO 单点登录，描述它的工作过程 <a class="header-anchor" href="#什么是-sso-单点登录-描述它的工作过程" aria-label="Permalink to &quot;什么是 SSO 单点登录，描述它的工作过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>SSO (Single Sign On) 单点登录是一种身份验证机制，允许用户使用一组凭证访问多个相关但独立的系统。</p><p>基本概念</p><ul><li>一次登录，全局通用</li><li>多个子系统共享用户会话</li><li>统一的认证中心</li><li>提高用户体验和安全性</li></ul><p>工作流程：</p><p>用户首次访问系统</p><ul><li>用户访问系统 A</li><li>系统 A 检查无登录状态</li><li>重定向到 SSO 认证中心</li><li>带上系统 A 的地址作为参数</li></ul><p>SSO 认证中心处理</p><ul><li>检查用户是否已登录 SSO</li><li>未登录则显示登录页面</li><li>用户输入账号密码</li><li>认证中心验证身份</li></ul><p>回到系统 A</p><ul><li>SSO 生成票据（ticket）</li><li>重定向回系统 A</li><li>带上票据参数</li><li>系统 A 验证票据</li><li>创建本地会话</li></ul><p>访问系统 B</p><ul><li>用户访问系统 B</li><li>系统 B 检查无登录状态</li><li>重定向到 SSO 认证中心</li><li>SSO 发现用户已登录</li><li>直接生成票据返回</li><li>系统 B 验证票据</li><li>创建本地会话</li></ul><p>实现方式：</p><ul><li>基于 Cookie</li><li>基于 Token</li><li>基于 SAML</li><li>基于 OAuth</li><li>基于 CAS</li></ul><p>优点：</p><ul><li>提升用户体验</li><li>减少密码管理</li><li>统一认证流程</li><li>提高安全性</li></ul><p>缺点：</p><ul><li>认证中心单点故障</li><li>配置相对复杂</li><li>需要额外的安全考虑</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7454474417318690831" target="_blank" rel="noreferrer">https://juejin.cn/post/7454474417318690831</a></li></ul></details><h2 id="什么是跨域-如何实现跨域通讯" tabindex="-1">什么是跨域？如何实现跨域通讯？ <a class="header-anchor" href="#什么是跨域-如何实现跨域通讯" aria-label="Permalink to &quot;什么是跨域？如何实现跨域通讯？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>跨域是指浏览器的同源策略限制，当前域名的 JavaScript 代码试图访问其他域名下的资源时会受到限制。</p><p>同源的定义：</p><ul><li>协议相同（http/https）</li><li>域名相同</li><li>端口相同</li></ul><p>跨域解决方案：</p><p>CORS（跨域资源共享）</p><ul><li>服务器设置 Access-Control-Allow-Origin 等响应头</li><li>可以配置允许的请求方法、请求头、是否允许携带认证信息等</li><li>最常用的跨域解决方案</li></ul><p>JSONP</p><ul><li>利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点</li><li>只支持 GET 请求</li><li>需要服务器配合返回 JavaScript 代码</li></ul><p>代理服务器</p><ul><li>开发环境：webpack-dev-server、vite 等的 proxy 配置</li><li>生产环境：Nginx 反向代理</li></ul><p>postMessage</p><ul><li>HTML5 标准中的 API</li><li>用于不同窗口间的跨域通信</li><li>可以在父子页面（iframe）或者多窗口间通信</li></ul><p>WebSocket</p><ul><li>建立在 TCP 之上的协议</li><li>天然支持跨域</li><li>适合需要实时通信的场景</li></ul><p>document.domain（已废弃）</p><ul><li>仅适用于主域名相同的情况</li><li>将子域和主域的 document.domain 设为相同的主域</li></ul><p>最佳实践：</p><ul><li>优先使用 CORS，配置得当的情况下最安全</li><li>需要兼容旧浏览器时可以考虑 JSONP</li><li>开发环境优先使用代理服务器</li><li>特殊场景（如页面通信）可以考虑 postMessage</li><li>需要实时通信时使用 WebSocket</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7346079038555602955" target="_blank" rel="noreferrer">https://juejin.cn/post/7346079038555602955</a></li></ul></details><h2 id="http-请求跨域时为何要发送-options-请求" tabindex="-1">HTTP 请求跨域时为何要发送 options 请求 <a class="header-anchor" href="#http-请求跨域时为何要发送-options-请求" aria-label="Permalink to &quot;HTTP 请求跨域时为何要发送 options 请求&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>OPTIONS 请求是 CORS 预检请求(Preflight Request)，用于检查实际请求是否可以安全地发送。</p><p>触发条件：</p><ul><li>使用非简单请求方法：除 GET、POST、HEAD 之外的方法</li><li>使用非简单请求头：除 Accept、Accept-Language、Content-Language、Content-Type 之外的请求头</li><li>Content-Type 不是以下之一： <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><p>工作流程：</p><ol><li><p>浏览器发送 OPTIONS 预检请求，包含：</p><ul><li>Origin：请求来源</li><li>Access-Control-Request-Method：实际请求使用的方法</li><li>Access-Control-Request-Headers：实际请求使用的请求头</li></ul></li><li><p>服务器响应预检请求，返回：</p><ul><li>Access-Control-Allow-Origin：允许的源</li><li>Access-Control-Allow-Methods：允许的方法</li><li>Access-Control-Allow-Headers：允许的请求头</li><li>Access-Control-Max-Age：预检请求的缓存时间</li></ul></li><li><p>如果预检通过，浏览器才会发送实际请求</p></li></ol><p>优化建议：</p><ul><li>尽可能使用简单请求，避免触发预检</li><li>合理设置 Access-Control-Max-Age 缓存预检结果</li><li>服务端正确配置 CORS 响应头</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7403185402347159588" target="_blank" rel="noreferrer">https://juejin.cn/post/7403185402347159588</a></li></ul></details><h2 id="options-请求会携带-cookie-吗" tabindex="-1">options 请求会携带 cookie 吗 <a class="header-anchor" href="#options-请求会携带-cookie-吗" aria-label="Permalink to &quot;options 请求会携带 cookie 吗&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>OPTIONS 请求通常不会携带 Cookie。它是一个预检请求，用于检查实际请求是否可以安全地发送。浏览器在发送 OPTIONS 请求时，不会自动附带 Cookie 和 Authorization 等认证信息，除非明确设置了 <code>credentials</code> 选项。</p><p>如果需要在 OPTIONS 请求中携带 Cookie，可以在请求中设置 <code>credentials: &#39;include&#39;</code>，但通常不推荐这样做，因为 OPTIONS 请求的目的就是检查跨域请求的安全性，而不是进行身份验证。</p></details><h2 id="简述浏览器的缓存策略" tabindex="-1">简述浏览器的缓存策略 <a class="header-anchor" href="#简述浏览器的缓存策略" aria-label="Permalink to &quot;简述浏览器的缓存策略&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>浏览器缓存策略主要分为两种：强缓存和协商缓存。</p><p>强缓存</p><ul><li>不需要向服务器发送请求，直接使用本地缓存</li><li>通过 HTTP 响应头控制： <ul><li>Cache-Control： <ul><li>max-age：缓存有效时间（秒）</li><li>no-cache：需要和服务器协商验证</li><li>no-store：不使用任何缓存</li><li>private：仅浏览器可缓存</li><li>public：中间代理/CDN 等也可缓存</li></ul></li><li>Expires：过期时间点（已被 Cache-Control 取代）</li></ul></li></ul><p>协商缓存</p><ul><li>需要向服务器发送请求验证资源是否有效</li><li>如果有效返回 304，使用本地缓存</li><li>通过以下响应头实现： <ul><li>Last-Modified/If-Modified-Since：基于文件修改时间</li><li>ETag/If-None-Match：基于文件内容哈希值</li></ul></li></ul><p>缓存位置（优先级从高到低）：</p><ol><li>Service Worker</li><li>Memory Cache（内存缓存）</li><li>Disk Cache（硬盘缓存）</li><li>Push Cache（HTTP/2）</li></ol><p>最佳实践：</p><ul><li>HTML：使用协商缓存</li><li>CSS、JS、图片：使用强缓存，文件名带 hash</li><li>API 请求：根据业务需求设置合适的缓存策略</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7352075703859183667" target="_blank" rel="noreferrer">https://juejin.cn/post/7352075703859183667</a></li></ul></details><h2 id="什么是图片防盗链-如何实现" tabindex="-1">什么是图片防盗链，如何实现？ <a class="header-anchor" href="#什么是图片防盗链-如何实现" aria-label="Permalink to &quot;什么是图片防盗链，如何实现？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>图片防盗链是指服务器通过 HTTP 协议中的 Referer 字段来判断请求是否来自合法站点，从而防止其他网站直接引用本站图片资源。</p><p>实现方式：</p><p>服务器端实现</p><ul><li>检查 HTTP Referer 字段</li><li>判断请求来源是否在白名单中</li><li>对非法请求返回 403 或替代图片</li></ul><p>Nginx 配置示例：</p><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ~</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> .*\\.(gif|jpg|jpeg|png|bmp)$ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    valid_referers </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">none blocked server_names *.example.com;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($invalid_referer) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 403</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 或者返回替代图片</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # rewrite ^/ /path/to/default.jpg break;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其他防盗链方案：</p><ul><li>给图片添加水印</li><li>使用 Token 验证</li><li>使用 CDN 提供的防盗链功能</li><li>对图片进行加密处理</li></ul><p>注意事项：</p><ul><li>Referer 可以被伪造，不能作为唯一判断依据</li><li>移动端 APP 可能不发送 Referer</li><li>部分浏览器可能禁用 Referer</li><li>需要考虑用户体验和 SEO 影响</li></ul></details><h2 id="简述-https-加密过程" tabindex="-1">简述 HTTPS 加密过程 <a class="header-anchor" href="#简述-https-加密过程" aria-label="Permalink to &quot;简述 HTTPS 加密过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>HTTPS 使用 TLS/SSL 协议进行加密，主要包含以下步骤：</p><p>客户端发起请求</p><ul><li>发送支持的加密算法列表</li><li>发送随机数 Client Random</li></ul><p>服务器回应</p><ul><li>选择加密算法</li><li>发送数字证书（包含公钥）</li><li>发送随机数 Server Random</li></ul><p>客户端验证证书</p><ul><li>验证证书是否由可信 CA 签发</li><li>验证证书域名是否匹配</li><li>验证证书是否在有效期内</li></ul><p>生成会话密钥</p><ul><li>客户端生成随机数 Pre-master secret</li><li>使用服务器公钥加密 Pre-master secret</li><li>客户端和服务器都通过三个随机数生成会话密钥 (Client Random + Server Random + Pre-master secret)</li></ul><p>开始加密通信</p><ul><li>双方使用会话密钥进行对称加密通信</li><li>保证通信内容的机密性和完整性</li></ul><p>特点：</p><ul><li>采用混合加密：非对称加密传输密钥，对称加密传输数据</li><li>数字证书保证服务器身份可信</li><li>具有防篡改和不可否认性</li></ul></details><h2 id="移动端-h5-如何抓包" tabindex="-1">移动端 H5 如何抓包？ <a class="header-anchor" href="#移动端-h5-如何抓包" aria-label="Permalink to &quot;移动端 H5 如何抓包？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>移动端 H5 抓包主要有以下几种方法：</p><p>Charles/Fiddler</p><ul><li>电脑端安装抓包工具</li><li>手机和电脑连接同一网络</li><li>手机设置代理为电脑 IP 和端口</li><li>安装并信任证书（HTTPS 抓包需要）</li></ul><p>优点：</p><ul><li>功能强大，可以查看详细请求信息</li><li>支持请求修改和重放</li><li>支持断点调试</li></ul><p>vConsole</p><ul><li>移动端调试面板</li><li>直接在页面中引入 js 文件</li><li>可以查看网络请求、console 日志等</li><li>适合开发环境使用</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://unpkg.com/vconsole/dist/vconsole.min.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  var vConsole = new VConsole();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Chrome Remote Debug</p><ul><li>安卓设备通过 USB 连接电脑</li><li>开启开发者模式和 USB 调试</li><li>Chrome 访问 chrome://inspect</li><li>可以使用完整的 Chrome DevTools</li></ul><p>Safari Web Inspector</p><ul><li>iOS 设备通过 USB 连接 Mac</li><li>开启 Web 检查器</li><li>Safari 开发菜单中选择设备</li><li>可以使用完整的 Safari 调试工具</li></ul><p>注意事项：</p><ul><li>HTTPS 抓包需要安装证书</li><li>部分 App 可能有反抓包机制</li><li>生产环境建议移除调试工具</li><li>注意数据安全和隐私保护</li></ul></details><h2 id="script-标签的-defer-和-async-有什么区别" tabindex="-1">script 标签的 defer 和 async 有什么区别 <a class="header-anchor" href="#script-标签的-defer-和-async-有什么区别" aria-label="Permalink to &quot;script 标签的 defer 和 async 有什么区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>script 标签的 defer 和 async 属性都是用于控制脚本的加载和执行时机：</p><p>普通 script</p><ul><li>阻塞 HTML 解析</li><li>立即下载并执行脚本</li><li>按照在文档中的顺序执行</li></ul><p>defer</p><ul><li>异步下载脚本，不阻塞 HTML 解析</li><li>等到 HTML 解析完成后，DOMContentLoaded 事件触发前执行</li><li>多个 defer 脚本按照在文档中的顺序执行</li><li>适用于需要操作 DOM 的脚本</li><li>只对外部脚本文件有效</li></ul><p>async</p><ul><li>异步下载脚本，不阻塞 HTML 解析</li><li>下载完成后立即执行，可能在 HTML 解析完成前执行</li><li>多个 async 脚本的执行顺序不确定，取决于下载完成时间</li><li>适用于独立的脚本，如统计和广告代码</li><li>只对外部脚本文件有效</li></ul><p>使用建议：</p><ul><li>需要操作 DOM 或依赖其他脚本的代码使用 defer</li><li>独立的、不依赖 DOM 和其他脚本的代码使用 async</li><li>如果脚本之间有依赖关系，不要使用 async</li></ul><p>示例：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 普通脚本 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- defer 脚本 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- async 脚本 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></details><h2 id="prefetch-和-dns-prefetch-分别是什么" tabindex="-1">prefetch 和 dns-prefetch 分别是什么 <a class="header-anchor" href="#prefetch-和-dns-prefetch-分别是什么" aria-label="Permalink to &quot;prefetch 和 dns-prefetch 分别是什么&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>prefetch 和 dns-prefetch 是两种不同的资源预加载技术：</p><p>prefetch</p><ul><li>用于预加载将来可能需要的资源</li><li>浏览器空闲时才会下载</li><li>优先级较低，不影响当前页面加载</li><li>适用于下一页可能用到的资源</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 预加载资源 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/next-page.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/images/large.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>dns-prefetch</p><ul><li>预先解析域名的 DNS 记录</li><li>减少 DNS 解析时间</li><li>适用于即将请求其他域名的资源</li><li>对跨域资源加载特别有效</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- DNS 预解析 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//api.example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>使用建议：</p><ul><li>对确定即将访问的资源使用 prefetch</li><li>对跨域资源较多的站点使用 dns-prefetch</li><li>不要过度预加载，可能浪费带宽</li><li>移动端要谨慎使用，考虑流量消耗</li></ul><p>相关技术：</p><ul><li>preload：当前页面必需资源的预加载</li><li>preconnect：预先建立连接（DNS + TCP + TLS）</li><li>prerender：预先渲染整个页面</li></ul></details><h2 id="websocket-和-http-协议有什么区别" tabindex="-1">WebSocket 和 HTTP 协议有什么区别 <a class="header-anchor" href="#websocket-和-http-协议有什么区别" aria-label="Permalink to &quot;WebSocket 和 HTTP 协议有什么区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>WebSocket 和 HTTP 的主要区别：</p><p>连接特性</p><ul><li>HTTP 是短连接：每次请求都需要建立新的 TCP 连接（除非使用 keep-alive）</li><li>WebSocket 是持久化的长连接：只需要一次握手，后续可以持续通信</li></ul><p>通信方式</p><ul><li>HTTP 是单向通信：客户端请求，服务器响应</li><li>WebSocket 是双向通信：客户端和服务器都可以主动发送数据</li></ul><p>数据格式</p><ul><li>HTTP 每次请求都要带完整的 HTTP 头</li><li>WebSocket 第一次握手完成后，后续数据传输只需要很小的头部</li></ul><p>应用场景</p><ul><li>HTTP 适合一次性的数据交互</li><li>WebSocket 适合实时性要求高的场景，如： <ul><li>实时聊天</li><li>游戏实时数据</li><li>实时协作文档</li></ul></li></ul><p>性能</p><ul><li>WebSocket 的性能和效率通常优于 HTTP 轮询</li><li>WebSocket 可以更好地节省服务器资源和带宽</li></ul><p>支持性</p><ul><li>HTTP 被所有浏览器支持</li><li>WebSocket 需要浏览器支持（现代浏览器普遍已支持）</li></ul></details><h2 id="如何上传文件-使用-fetch-或者-axios" tabindex="-1">如何上传文件？使用 fetch 或者 axios <a class="header-anchor" href="#如何上传文件-使用-fetch-或者-axios" aria-label="Permalink to &quot;如何上传文件？使用 fetch 或者 axios&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>文件上传主要有以下几种方式：</p><p>使用 FormData</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// HTML</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// fetch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const file = document.querySelector(&#39;#file&#39;).files[0]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const formData = new FormData()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">formData.append(&#39;file&#39;, file)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fetch(&#39;/upload&#39;, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    body: formData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// axios</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const formData = new FormData()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">formData.append(&#39;file&#39;, file)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.post(&#39;/upload&#39;, formData, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;multipart/form-data&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>使用 Base64</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将文件转为 Base64</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fileToBase64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FileReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reader.result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readAsDataURL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// fetch</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> base64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fileToBase64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/upload&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ file: base64 }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// axios</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> base64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fileToBase64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/upload&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  file: base64,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>多文件上传</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// HTML</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> multiple</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;files&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// fetch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const files = document.querySelector(&#39;#files&#39;).files</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const formData = new FormData()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Array.from(files).forEach(file =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;files&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, file)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fetch(&#39;/upload&#39;, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    body: formData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// axios</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const formData = new FormData()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Array.from(files).forEach(file =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;files&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, file)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.post(&#39;/upload&#39;, formData)</span></span></code></pre></div><p>注意事项：</p><ul><li>设置正确的 Content-Type</li><li>考虑文件大小限制</li><li>添加上传进度显示</li><li>处理上传错误</li><li>考虑文件类型限制</li><li>添加取消上传功能</li></ul></details><h2 id="如何上传大文件" tabindex="-1">如何上传大文件？ <a class="header-anchor" href="#如何上传大文件" aria-label="Permalink to &quot;如何上传大文件？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>大文件上传主要有以下几种方案：</p><p>切片上传</p><ul><li>将大文件分割成小块</li><li>并发上传多个切片</li><li>服务端合并所有切片</li><li>支持断点续传和进度显示</li></ul><p>实现步骤： 前端切片</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createFileChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.size) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    chunks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cur, cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunks</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上传切片</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uploadChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> requests</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunks.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> formData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FormData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;chunk&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, chunk)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    formData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/upload&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, formData)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(requests)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>发送合并请求</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/merge&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  filename: file.name,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  size: chunks.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>断点续传</p><ul><li>记录已上传的切片</li><li>重新上传时跳过已上传的部分</li><li>可以通过 localStorage 存储进度</li><li>使用 hash 标识文件和切片</li></ul><p>秒传</p><ul><li>上传前先发送文件 hash</li><li>服务端存在相同文件则直接返回</li><li>可以使用 spark-md5 计算文件 hash</li></ul><p>性能优化</p><ul><li>并发控制：限制同时上传的切片数</li><li>切片大小：根据网络状况动态调整</li><li>进度显示：计算整体上传进度</li><li>错误重试：单个切片上传失败后重试</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7356817667574136884" target="_blank" rel="noreferrer">https://juejin.cn/post/7356817667574136884</a></li></ul></details><h2 id="如何实现图片懒加载" tabindex="-1">如何实现图片懒加载？ <a class="header-anchor" href="#如何实现图片懒加载" aria-label="Permalink to &quot;如何实现图片懒加载？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>IntersectionObserver API</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IntersectionObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  entries.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (entry.isIntersecting) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      entry.target.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry.target.dataset.original</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      entry.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data-original&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unobserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entry.target)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> imgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;img[data-original]&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">imgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>原生 loading 属性</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewHeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.innerHeight</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lazyLoad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> imgs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;img[data-original]&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  imgs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBoundingClientRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (rect.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewHeight) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> image </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      image.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.dataset.original</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      image.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        el.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> image.src</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;data-original&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lazyLoad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 页面初始加载时调用一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;scroll&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lazyLoad)</span></span></code></pre></div></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7320513026188116003" target="_blank" rel="noreferrer">https://juejin.cn/post/7320513026188116003</a></li></ul></details><h2 id="在网络层面可做哪些性能优化" tabindex="-1">在网络层面可做哪些性能优化？ <a class="header-anchor" href="#在网络层面可做哪些性能优化" aria-label="Permalink to &quot;在网络层面可做哪些性能优化？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>网络性能优化可以从以下几个方面考虑：</p><p>减少请求数量</p><ul><li>合并文件（CSS/JS 打包）</li><li>雪碧图（CSS Sprites）</li><li>图片懒加载</li><li>按需加载/异步加载</li><li>合理使用缓存</li></ul><p>减小资源体积</p><ul><li>代码压缩（minify）</li><li>Gzip/Brotli 压缩</li><li>图片优化（压缩、webp格式）</li><li>Tree Shaking</li><li>代码分割（Code Splitting）</li></ul><p>CDN 优化</p><ul><li>使用 CDN 分发静态资源</li><li>合理设置 CDN 缓存</li><li>选择合适的 CDN 节点</li><li>配置 CDN 预热和刷新策略</li></ul><p>HTTP 优化</p><ul><li>使用 HTTP/2 多路复用</li><li>开启 Keep-Alive</li><li>合理设置缓存策略</li><li>DNS 预解析（dns-prefetch）</li><li>预连接（preconnect）</li><li>预加载（prefetch/preload）</li></ul><p>资源加载优化</p><ul><li>关键资源优先加载</li><li>非关键资源延迟加载</li><li>内联关键 CSS/JS</li><li>异步加载非关键 JS（async/defer）</li><li>优化资源加载顺序</li></ul><p>接口优化</p><ul><li>接口合并</li><li>GraphQL 按需查询</li><li>数据缓存</li><li>避免重复请求</li><li>设置合理的超时时间</li></ul><p>监控和分析</p><ul><li>性能监控</li><li>错误监控</li><li>用户体验监控</li><li>性能数据分析</li><li>持续优化</li></ul></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7362080157237116978" target="_blank" rel="noreferrer">https://juejin.cn/post/7362080157237116978</a></li></ul></details>`,113)]))}const c=s(t,[["render",e]]);export{o as __pageData,c as default};
