import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.CDk703ml.js";const g=JSON.parse('{"title":"React 原理","description":"","frontmatter":{},"headers":[],"relativePath":"docs/second-exam/react-inner.md","filePath":"docs/second-exam/react-inner.md"}'),l={name:"docs/second-exam/react-inner.md"};function e(p,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="react-原理" tabindex="-1">React 原理 <a class="header-anchor" href="#react-原理" aria-label="Permalink to &quot;React 原理&quot;">​</a></h1><p>国内面试，大厂必考原理。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>目标<strong>不在</strong>中大厂的同学，可以略过这一节。</li><li>对 React 使用尚不熟练的同学，不要在此花费太多精力，先熟悉使用再说。</li></ol></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如有疑问，可免费 <a href="/mianshi/docs/services/group.html">加群</a> 讨论咨询，也可参与 <a href="/mianshi/docs/services/1v1.html">1v1 面试咨询服务</a>， 专业、系统、高效、全流程 准备前端面试</p></div><h2 id="jsx-的本质是什么" tabindex="-1">JSX 的本质是什么？ <a class="header-anchor" href="#jsx-的本质是什么" aria-label="Permalink to &quot;JSX 的本质是什么？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p><strong>JSX（JavaScript XML）</strong> 是一个 JavaScript 的语法扩展，允许在 JavaScript 代码中通过类 HTML 语法创建 React 元素。它需要通过 Babel 等工具编译为标准的 JavaScript 代码，最终生成 <strong>React 元素对象</strong>（React Element），这些元素共同构成虚拟 DOM（Virtual DOM）树。</p><p><strong>核心原理</strong></p><ol><li><p><strong>JSX 编译为 React 元素</strong> JSX 会被转换为 <code>React.createElement()</code> 调用（或 React 17+ 的 <code>_jsx</code> 函数），生成描述 UI 结构的对象（React 元素），而非直接操作真实 DOM。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;title&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, world!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（React 17 之前）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;title&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, world!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（React 17+，自动引入 _jsx）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { jsx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _jsx } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react/jsx-runtime&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _jsx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;title&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, world!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div></li><li><p><strong>虚拟 DOM 的运作</strong></p><ul><li>React 元素组成虚拟 DOM 树，通过 Diff 算法对比新旧树差异，最终高效更新真实 DOM。</li><li>虚拟 DOM 是内存中的轻量对象，避免频繁操作真实 DOM 的性能损耗。</li></ul></li></ol><p><strong>JSX 的核心特性</strong></p><ol><li><p><strong>类 HTML 语法与 JavaScript 的融合</strong></p><ul><li><strong>表达式嵌入</strong>：通过 <code>{}</code> 嵌入 JavaScript 表达式（如变量、函数调用、三元运算符）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Alice&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {userName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><strong>禁止语句</strong>：<code>{}</code> 内不支持 <code>if</code>/<code>for</code> 等语句，需改用表达式（如三元运算符或逻辑与）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{isLoggedIn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Welcome&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Please Login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul></li><li><p><strong>语法规则</strong></p><ul><li><strong>属性命名</strong>：使用驼峰命名（如 <code>className</code> 代替 <code>class</code>，<code>htmlFor</code> 代替 <code>for</code>）。</li><li><strong>闭合标签</strong>：所有标签必须显式闭合（如 <code>&lt;img /&gt;</code>）。</li><li><strong>单一根元素</strong>：JSX 必须有唯一根元素（或用 <code>&lt;&gt;&lt;/&gt;</code> 空标签包裹）。</li></ul></li><li><p><strong>安全性</strong></p><ul><li><strong>默认 XSS 防护</strong>：JSX 自动转义嵌入内容中的特殊字符（如 <code>&lt;</code> 转为 <code>&amp;lt;</code>）。</li><li><strong>例外场景</strong>：如需渲染原始 HTML，需显式使用 <code>dangerouslySetInnerHTML</code>（需谨慎）：<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dangerouslySetInnerHTML</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ __html: userContent }} /&gt;</span></span></code></pre></div></li></ul></li></ol><p><strong>编译与工具链</strong></p><ol><li><p><strong>编译流程</strong> JSX 需通过 <strong>Babel</strong> 编译为浏览器可执行的 JavaScript。典型配置如下：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// .babelrc</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;presets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>React 17+ 的优化</strong></p><ul><li>无需手动导入 React：编译器自动引入 <code>_jsx</code> 函数。</li><li>更简洁的编译输出：减少代码体积，提升可读性。</li></ul></li></ol></details><p>参考资料</p><details class="details custom-block"><summary>Details</summary><ul><li><a href="https://juejin.cn/post/7348651815759282226" target="_blank" rel="noreferrer">https://juejin.cn/post/7348651815759282226</a></li></ul></details><h2 id="如何理解-react-fiber-架构" tabindex="-1">如何理解 React Fiber 架构？ <a class="header-anchor" href="#如何理解-react-fiber-架构" aria-label="Permalink to &quot;如何理解 React Fiber 架构？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>Fiber 架构的本质与设计目标</strong></li></ol><p>Fiber 是 React 16+ 的<strong>核心算法重写</strong>，本质是<strong>基于链表的增量式协调模型</strong>。其核心目标并非单纯提升性能，而是重构架构以实现：</p><ul><li><strong>可中断的异步渲染</strong>：将同步递归的调和过程拆解为可暂停/恢复的异步任务。</li><li><strong>优先级调度</strong>：高优先级任务（如用户输入）可打断低优先级任务（如数据更新）。</li><li><strong>并发模式基础</strong>：为 <code>Suspense</code>、<code>useTransition</code> 等特性提供底层支持。</li></ul><ol start="2"><li><strong>Fiber 节点的核心设计</strong></li></ol><p>每个组件对应一个 <strong>Fiber 节点</strong>，构成<strong>双向链表树结构</strong>，包含以下关键信息：</p><ul><li><strong>组件类型</strong>：函数组件、类组件或原生标签。</li><li><strong>状态与副作用</strong>：Hooks 状态（如 <code>useState</code>）、生命周期标记（如 <code>useEffect</code>）。</li><li><strong>调度信息</strong>：任务优先级（<code>lane</code> 模型）、到期时间（<code>expirationTime</code>）。</li><li><strong>链表指针</strong>：<code>child</code>（子节点）、<code>sibling</code>（兄弟节点）、<code>return</code>（父节点）。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fiber 节点结构简化示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: FunctionComponent, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stateNode: ComponentFunc, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件实例或 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Hooks 链表 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pendingProps: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 待处理 props */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lanes: Lanes.HighPriority, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任务优先级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  child: nextFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sibling: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 兄弟节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return: parentFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li><strong>Fiber 协调流程（两阶段提交）</strong></li></ol><p><strong>阶段 1：Reconciliation（协调/渲染阶段）</strong></p><ul><li><strong>可中断的增量计算</strong>： React 将组件树遍历拆解为多个 <strong>Fiber 工作单元</strong>，通过循环（而非递归）逐个处理。 <ul><li>每次循环执行一个 Fiber 节点，生成子 Fiber 并连接成树。</li><li>通过 <code>requestIdleCallback</code>（或 Scheduler 包）在浏览器空闲时段执行，避免阻塞主线程。</li></ul></li><li><strong>对比策略</strong>： 根据 <code>key</code> 和 <code>type</code> 复用节点，标记 <code>Placement</code>（新增）、<code>Update</code>（更新）、<code>Deletion</code>（删除）等副作用。</li></ul><p><strong>阶段 2：Commit（提交阶段）</strong></p><ul><li><strong>不可中断的 DOM 更新</strong>： 同步执行所有标记的副作用（如 DOM 操作、生命周期调用），确保 UI 一致性。</li><li><strong>副作用分类</strong>： <ul><li><strong>BeforeMutation</strong>：<code>getSnapshotBeforeUpdate</code>。</li><li><strong>Mutation</strong>：DOM 插入/更新/删除。</li><li><strong>Layout</strong>：<code>useLayoutEffect</code>、<code>componentDidMount</code>/<code>Update</code>。</li></ul></li></ul><ol start="4"><li><strong>优先级调度机制</strong></li></ol><p>React 通过 <strong>Lane 模型</strong> 管理任务优先级（共 31 个优先级车道）：</p><ul><li><strong>事件优先级</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优先级从高到低</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ImmediatePriority（用户输入）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UserBlockingPriority（悬停、点击）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NormalPriority（数据请求）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LowPriority（分析日志）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IdlePriority（非必要任务）</span></span></code></pre></div></li><li><strong>调度策略</strong>： <ul><li>高优先级任务可抢占低优先级任务的执行权。</li><li>过期任务（如 Suspense 回退）会被强制同步执行。</li></ul></li></ul><ol start="5"><li><strong>Fiber 架构的优势与局限性</strong></li></ol><p><strong>优势</strong></p><ul><li><strong>流畅的用户体验</strong>：异步渲染避免主线程阻塞，保障高优先级任务即时响应。</li><li><strong>复杂场景优化</strong>：支持大规模组件树的高效更新（如虚拟滚动、动画串联）。</li><li><strong>未来特性基础</strong>：为并发模式（Concurrent Mode）、离线渲染（SSR）提供底层支持。</li></ul><p><strong>局限性</strong></p><ul><li><strong>学习成本高</strong>：开发者需理解底层调度逻辑以优化性能。</li><li><strong>内存开销</strong>：Fiber 树的双向链表结构比传统虚拟 DOM 占用更多内存。</li></ul><ol start="6"><li><strong>与旧架构的关键差异</strong></li></ol><table tabindex="0"><thead><tr><th>特性</th><th>Stack Reconciler（React 15-）</th><th>Fiber Reconciler（React 16+）</th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>递归（不可中断）</td><td>循环（可中断 + 恢复）</td></tr><tr><td><strong>任务调度</strong></td><td>同步执行，阻塞主线程</td><td>异步分片，空闲时段执行</td></tr><tr><td><strong>优先级控制</strong></td><td>无</td><td>基于 Lane 模型的优先级抢占</td></tr><tr><td><strong>数据结构</strong></td><td>虚拟 DOM 树</td><td>Fiber 链表树（含调度信息）</td></tr></tbody></table></details><h2 id="fiber-结构和普通-vnode-区别" tabindex="-1">Fiber 结构和普通 VNode 区别 <a class="header-anchor" href="#fiber-结构和普通-vnode-区别" aria-label="Permalink to &quot;Fiber 结构和普通 VNode 区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>本质差异</strong></li></ol><table tabindex="0"><thead><tr><th>维度</th><th>普通 VNode（虚拟 DOM）</th><th>Fiber 结构</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>减少真实 DOM 操作，提升渲染性能</td><td>实现可中断的异步渲染 + 优先级调度</td></tr><tr><td><strong>数据结构</strong></td><td>树形结构（递归遍历）</td><td>双向链表树（循环遍历）</td></tr><tr><td><strong>功能范畴</strong></td><td>仅描述 UI 结构</td><td>描述 UI 结构 + 调度任务 + 副作用管理</td></tr></tbody></table><ol start="2"><li><strong>数据结构对比</strong></li></ol><p><strong>普通 VNode（React 15 及之前）</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类型（组件/原生标签）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  children: [vNode1, vNode2], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 子节点（树形结构）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unique-id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优化 Diff 性能</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 无状态、调度、副作用信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>核心字段</strong>：仅包含 UI 描述相关属性（type、props、children）。</li></ul><p><strong>Fiber 节点（React 16+）</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fiberNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: HostComponent, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类型（函数组件/类组件/DOM元素）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原生标签或组件构造函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unique-id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Diff 优化标识</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  stateNode: domNode, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 关联的真实 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pendingProps: { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 待处理的 props</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedProps: {}, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 已生效的 props</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Hooks 状态（函数组件）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hooks: [state1, effectHook],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  updateQueue: [], </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态更新队列（类组件）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lanes: Lanes.HighPriority, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调度优先级（Lane 模型）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  child: childFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sibling: siblingFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 下一个兄弟节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return: parentFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 父节点（构成双向链表）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  effectTag: Placement, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用标记（插入/更新/删除）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nextEffect: nextEffectFiber, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 副作用链表指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>核心扩展</strong>： <ul><li><strong>调度控制</strong>：<code>lanes</code> 优先级、任务到期时间。</li><li><strong>状态管理</strong>：Hooks 链表（函数组件）、类组件状态队列。</li><li><strong>副作用追踪</strong>：<code>effectTag</code> 标记和副作用链表。</li><li><strong>遍历结构</strong>：<code>child</code>/<code>sibling</code>/<code>return</code> 构成双向链表。</li></ul></li></ul><ol start="3"><li><strong>协调机制对比</strong></li></ol><table tabindex="0"><thead><tr><th>流程</th><th>VNode（Stack Reconciler）</th><th>Fiber Reconciler</th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>递归遍历（不可中断）</td><td>循环遍历链表（可中断 + 恢复）</td></tr><tr><td><strong>任务调度</strong></td><td>同步执行，阻塞主线程</td><td>异步分片，空闲时间执行</td></tr><tr><td><strong>优先级控制</strong></td><td>无</td><td>Lane 模型（31 个优先级车道）</td></tr><tr><td><strong>副作用处理</strong></td><td>统一提交 DOM 更新</td><td>构建副作用链表，分阶段提交</td></tr></tbody></table><ul><li><strong>Fiber 两阶段提交</strong>： <ol><li><strong>协调阶段</strong>（可中断）： <ul><li>增量构建 Fiber 树，标记副作用（<code>effectTag</code>）。</li><li>通过 <code>requestIdleCallback</code> 或 Scheduler 包分片执行。</li></ul></li><li><strong>提交阶段</strong>（同步不可中断）： <ul><li>遍历副作用链表，执行 DOM 操作和生命周期方法。</li></ul></li></ol></li></ul><ol start="4"><li><p><strong>能力扩展示例</strong></p><p><strong>a. 支持 Hooks 状态管理</strong></p></li></ol><ul><li>Fiber 节点通过 <code>memoizedState</code> 字段存储 Hooks 链表：</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数组件的 Hooks 链表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fiberNode.memoizedState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;state value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useState 的状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 下一个 Hook（如 useEffect）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    memoizedState: { cleanup: fn },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    next: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>VNode 无状态管理能力，仅描述 UI。</li></ul><p><strong>b. 优先级调度实战</strong></p><ul><li><strong>高优先级任务抢占</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户输入触发高优先级更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">input.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startTransition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setInputValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target.value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 低优先级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 高优先级更新立即执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li>VNode 架构无法实现任务中断和优先级插队。</li></ul><p><strong>c. 副作用批处理</strong></p><ul><li>Fiber 通过 <code>effectList</code> 链表收集所有变更，统一提交：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 提交阶段遍历 effectList</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fiberRoot.firstEffect</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextEffect) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  commitWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextEffect)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nextEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextEffect.nextEffect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li>VNode 架构在 Diff 后直接操作 DOM，无批处理优化。</li></ul><ol start="5"><li><strong>性能影响对比</strong></li></ol><table tabindex="0"><thead><tr><th>场景</th><th>VNode 架构</th><th>Fiber 架构</th></tr></thead><tbody><tr><td><strong>大型组件树渲染</strong></td><td>主线程阻塞导致掉帧</td><td>分片渲染，保持 UI 响应</td></tr><tr><td><strong>高频更新（如动画）</strong></td><td>多次渲染合并困难</td><td>基于优先级合并或跳过中间状态</td></tr><tr><td><strong>SSR 水合（Hydration）</strong></td><td>全量同步处理</td><td>增量水合，优先交互部分</td></tr></tbody></table></details><h2 id="简述-react-diff-算法过程" tabindex="-1">简述 React diff 算法过程 <a class="header-anchor" href="#简述-react-diff-算法过程" aria-label="Permalink to &quot;简述 React diff 算法过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React Diff 算法通过 <strong>分层对比策略</strong> 和 <strong>启发式规则</strong> 减少树对比的时间复杂度（从 O(n³) 优化至 O(n)）。其核心流程如下：</p><p><strong>1. 分层对比策略</strong></p><p>React 仅对 <strong>同一层级的兄弟节点</strong> 进行对比，若节点跨层级移动（如从父节点 A 移动到父节点 B），则直接 <strong>销毁并重建</strong>，而非移动。 <strong>原因</strong>：跨层操作在真实 DOM 中成本极高（需递归遍历子树），而实际开发中跨层移动场景极少，此策略以概率换性能。</p><p><strong>2. 节点类型比对规则</strong></p><p><strong>a. 元素类型不同</strong></p><p>若新旧节点类型不同（如 <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code> 或 <code>ComponentA</code> → <code>ComponentB</code>），则：</p><ol><li>销毁旧节点及其子树。</li><li>创建新节点及子树，并插入 DOM。</li></ol><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧树</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ComponentA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新树 → 直接替换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ComponentB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>b. 元素类型相同</strong></p><p>若类型相同，则复用 DOM 节点并更新属性：</p><ul><li><strong>原生标签</strong>：更新 <code>className</code>、<code>style</code> 等属性。</li><li><strong>组件类型</strong>： <ul><li>类组件：保留实例，触发 <code>componentWillReceiveProps</code> → <code>shouldComponentUpdate</code> 等生命周期。</li><li>函数组件：重新执行函数，通过 Hooks 状态判断是否需更新。</li></ul></li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧组件（保留实例并更新 props）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;old&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleClick} /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新组件 → 复用 DOM，更新 className 和 onClick</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;new&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{newClick} /&gt;</span></span></code></pre></div><p><strong>3. 列表节点的 Key 优化</strong></p><p>处理子节点列表时，React 依赖 <strong>key</strong> 进行最小化更新：</p><p><strong>a. 无 key 时的默认行为</strong></p><p>默认使用 <strong>索引匹配</strong>（index-based diff），可能导致性能问题：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;[&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;A&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;B&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;][</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 新列表（首部插入）→ 索引对比导致 B 被误判更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ((&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;C&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;), (&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;A&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;), (&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;B&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>此时 React 会认为索引 0 从 A → C（更新），索引 1 从 B → A（更新），并新增索引 2 的 B，实际应仅插入 C。</p><p><strong>b. 使用 key 的优化匹配</strong></p><p>通过唯一 key 标识节点身份，React 可精准识别移动/新增/删除：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正确使用 key（如数据 ID）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id}&gt;{item.text}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>匹配规则</strong>：</p><ol><li><p>遍历新列表，通过 key 查找旧节点：</p><ul><li>找到且类型相同 → 复用节点。</li><li>未找到 → 新建节点。</li></ul></li><li><p>记录旧节点中未被复用的节点 → 执行删除。</p></li></ol><p><strong>c. 节点移动优化</strong></p><p>若新旧列表节点仅顺序变化，React 通过 key 匹配后，仅执行 <strong>DOM 移动操作</strong>（非重建），例如：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：A (key=1), B (key=2)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：B (key=2), A (key=1)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 仅交换 DOM 顺序，而非销毁重建</span></span></code></pre></div><p><strong>4. 性能边界策略</strong></p><ul><li><strong>子树跳过</strong>：若父节点类型变化，其子节点即使未变化也会被整体销毁。</li><li><strong>相同组件提前终止</strong>：若组件 <code>shouldComponentUpdate</code> 返回 <code>false</code>，则跳过其子树 Diff。</li></ul></details><h2 id="react-和-vue-diff-算法的区别" tabindex="-1">React 和 Vue diff 算法的区别 <a class="header-anchor" href="#react-和-vue-diff-算法的区别" aria-label="Permalink to &quot;React 和 Vue diff 算法的区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 和 Vue 的 Diff 算法均基于虚拟 DOM，但在实现策略、优化手段和设计哲学上存在显著差异：</p><p><strong>1. 核心算法策略对比</strong></p><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>React</strong></th><th><strong>Vue 2/3</strong></th></tr></thead><tbody><tr><td><strong>遍历方式</strong></td><td>单向递归（同层顺序对比）</td><td>双端对比（头尾指针优化）</td></tr><tr><td><strong>节点复用</strong></td><td>类型相同则复用，否则销毁重建</td><td>类型相同则尝试复用，优先移动而非重建</td></tr><tr><td><strong>静态优化</strong></td><td>需手动优化（如 <code>React.memo</code>）</td><td>编译阶段自动标记静态节点</td></tr><tr><td><strong>更新粒度</strong></td><td>组件级更新（默认）</td><td>组件级 + 块级（Vue3 Fragments）</td></tr></tbody></table><p><strong>2. 列表 Diff 实现细节</strong></p><p><strong>a. React 的索引对比策略</strong></p><ul><li><strong>无 key 时</strong>：按索引顺序对比，可能导致无效更新<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：[A, B, C]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：[D, A, B, C]（插入头部）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 对比结果：更新索引 0-3，性能低下</span></span></code></pre></div></li><li><strong>有 key 时</strong>：通过 key 匹配节点，减少移动操作<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// key 匹配后，仅插入 D，其他节点不更新</span></span></code></pre></div></li></ul><p><strong>b. Vue 的双端对比策略</strong></p><p>分四步优化对比效率（Vue2 核心逻辑，Vue3 优化为最长递增子序列）：</p><ol><li><strong>头头对比</strong>：新旧头指针节点相同则复用，指针后移</li><li><strong>尾尾对比</strong>：新旧尾指针节点相同则复用，指针前移</li><li><strong>头尾交叉对比</strong>：旧头 vs 新尾，旧尾 vs 新头</li><li><strong>中间乱序对比</strong>：建立 key-index 映射表，复用可匹配节点</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧列表：[A, B, C, D]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新列表：[D, A, B, C]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 通过步骤3头尾对比，仅移动 D 到头部</span></span></code></pre></div><p><strong>3. 静态优化机制</strong></p><p><strong>a. Vue 的编译时优化</strong></p><ul><li><p><strong>静态节点标记</strong>： 模板中的静态节点（无响应式绑定）会被编译为常量，跳过 Diff</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 编译前 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello Vue&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 编译后 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_hoisted_1 = createVNode(&quot;div&quot;, null, &quot;Hello Vue&quot;)</span></span></code></pre></div></li><li><p><strong>Block Tree（Vue3）</strong>： 动态节点按区块（Block）组织，Diff 时仅对比动态部分</p></li></ul><p><strong>b. React 的运行时优化</strong></p><ul><li><strong>手动控制更新</strong>： 需通过 <code>React.memo</code>、<code>shouldComponentUpdate</code> 或 <code>useMemo</code> 避免无效渲染<div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MemoComp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Static Content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span></code></pre></div></li></ul><p><strong>4. 响应式更新触发</strong></p><table tabindex="0"><thead><tr><th><strong>框架</strong></th><th><strong>机制</strong></th><th><strong>Diff 触发条件</strong></th></tr></thead><tbody><tr><td>React</td><td>状态变化触发组件重新渲染</td><td>父组件渲染 → 子组件默认递归 Diff</td></tr><tr><td>Vue</td><td>响应式数据变更触发组件更新</td><td>依赖收集 → 仅受影响组件触发 Diff</td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue：只有 data.value 变化才会触发更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ data: { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React：需显式调用 setState</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>5. 设计哲学差异</strong></p><table tabindex="0"><thead><tr><th><strong>维度</strong></th><th><strong>React</strong></th><th><strong>Vue</strong></th></tr></thead><tbody><tr><td><strong>控制粒度</strong></td><td>组件级控制（开发者主导）</td><td>细粒度依赖追踪（框架主导）</td></tr><tr><td><strong>优化方向</strong></td><td>运行时优化（Fiber 调度）</td><td>编译时优化（模板静态分析）</td></tr><tr><td><strong>适用场景</strong></td><td>大型动态应用（需精细控制）</td><td>中小型应用（快速开发）</td></tr></tbody></table></details><h2 id="react-jsx-循环为何使用-key" tabindex="-1">React JSX 循环为何使用 <code>key</code> ？ <a class="header-anchor" href="#react-jsx-循环为何使用-key" aria-label="Permalink to &quot;React JSX 循环为何使用 \`key\` ？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>元素的高效识别与复用</strong></li></ol><p>React 通过 <code>key</code> 唯一标识列表中的每个元素。当列表发生变化（增删改排序）时，React 会通过 <code>key</code> 快速判断：</p><ul><li><strong>哪些元素是新增的</strong>（需要创建新 DOM 节点）</li><li><strong>哪些元素是移除的</strong>（需要销毁旧 DOM 节点）</li><li><strong>哪些元素是移动的</strong>（直接复用现有 DOM 节点，仅调整顺序）</li></ul><p>如果没有 <code>key</code>，React 会默认使用数组索引（<code>index</code>）作为标识，这在动态列表中会导致 <strong>性能下降</strong> 或 <strong>状态错误</strong>。</p><ol start="2"><li><strong>避免状态混乱</strong></li></ol><p>如果列表项是 <strong>有状态的组件</strong>（比如输入框、勾选框等），错误的 <code>key</code> 会导致状态与错误的内容绑定。例如：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果初始列表是 [A, B]，用索引 index 作为 key：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{index}&gt;{item}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ))}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在头部插入新元素变为 [C, A, B] 时：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 会认为 key=0 → C（重新创建）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// key=1 → A（复用原 key=0 的 DOM，但状态可能残留）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时，原本属于 A 的输入框状态可能会错误地出现在 C 中。</span></span></code></pre></div><ol start="3"><li><strong>提升渲染性能</strong></li></ol><p>通过唯一且稳定的 <code>key</code>（如数据 ID），React 可以精准判断如何复用 DOM 节点。如果使用随机数或索引，每次渲染都会强制重新创建所有元素，导致性能浪费。</p></details><h2 id="react-事件和-dom-事件区别" tabindex="-1">React 事件和 DOM 事件区别 <a class="header-anchor" href="#react-事件和-dom-事件区别" aria-label="Permalink to &quot;React 事件和 DOM 事件区别&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><ol><li><strong>事件绑定方式</strong></li></ol><ul><li><p><strong>React 事件</strong> 使用<strong>驼峰命名法</strong>（如 <code>onClick</code>、<code>onChange</code>），通过 JSX 属性直接绑定函数：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleClick}&gt;点击&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>DOM 事件</strong> 使用<strong>全小写命名</strong>（如 <code>onclick</code>、<code>onchange</code>），通过字符串或 <code>addEventListener</code> 绑定：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onclick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleClick</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;点击&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleClick)</span></span></code></pre></div></li></ul><ol start="2"><li><strong>事件对象（Event Object）</strong></li></ol><ul><li><p><strong>React 事件</strong> 使用<strong>合成事件（SyntheticEvent）</strong>，是原生事件对象的跨浏览器包装。</p><ul><li>通过 <code>e.nativeEvent</code> 访问原生事件。</li><li>事件对象会被复用（事件池机制），异步访问需调用 <code>e.persist()</code>。</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">persist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保持事件对象引用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>DOM 事件</strong> 直接使用浏览器原生事件对象，无复用机制。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li></ul><ol start="3"><li><strong>事件传播与默认行为</strong></li></ol><ul><li><p><strong>React 事件</strong></p><ul><li><strong>阻止默认行为</strong>：必须显式调用 <code>e.preventDefault()</code>。</li><li><strong>阻止冒泡</strong>：调用 <code>e.stopPropagation()</code>。</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻止表单默认提交</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stopPropagation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻止事件冒泡</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>DOM 事件</strong></p><ul><li><strong>阻止默认行为</strong>：可调用 <code>e.preventDefault()</code> 或 <code>return false</code>（在 HTML 属性中）。</li><li><strong>阻止冒泡</strong>：调用 <code>e.stopPropagation()</code> 或 <code>return false</code>（仅部分情况）。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onsubmit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 阻止默认提交 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onclick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stopPropagation</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;按钮&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><ol start="4"><li><strong>性能优化</strong></li></ol><ul><li><p><strong>React 事件</strong> 采用<strong>事件委托</strong>机制：</p><ul><li>React 17 之前将事件委托到 <code>document</code> 层级。</li><li>React 17+ 改为委托到渲染的根容器（如 <code>ReactDOM.render</code> 挂载的节点）。</li><li>减少内存占用，动态添加元素无需重新绑定事件。</li></ul></li><li><p><strong>DOM 事件</strong> 直接绑定到元素，大量事件监听时可能导致性能问题。</p></li></ul><ol start="5"><li><strong>跨浏览器兼容性</strong></li></ol><ul><li><p><strong>React 事件</strong> 合成事件抹平了浏览器差异（如 <code>event.target</code> 的一致性），无需处理兼容性问题。</p></li><li><p><strong>DOM 事件</strong> 需手动处理浏览器兼容性（如 IE 的 <code>attachEvent</code> vs 标准 <code>addEventListener</code>）。</p></li></ul><ol start="6"><li><strong><code>this</code> 绑定</strong></li></ol><ul><li><p><strong>React 事件</strong> 类组件中需手动绑定 <code>this</code> 或使用箭头函数：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  handleClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需绑定，否则为 undefined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.handleClick.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;点击&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>DOM 事件</strong> 事件处理函数中的 <code>this</code> 默认指向触发事件的元素：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指向 button 元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li></ul><table tabindex="0"><thead><tr><th>特性</th><th>React 事件</th><th>DOM 事件</th></tr></thead><tbody><tr><td><strong>命名规则</strong></td><td>驼峰命名（<code>onClick</code>）</td><td>全小写（<code>onclick</code>）</td></tr><tr><td><strong>事件对象</strong></td><td>合成事件（<code>SyntheticEvent</code>）</td><td>原生事件对象</td></tr><tr><td><strong>默认行为阻止</strong></td><td><code>e.preventDefault()</code></td><td><code>e.preventDefault()</code> 或 <code>return false</code></td></tr><tr><td><strong>事件委托</strong></td><td>自动委托到根容器</td><td>需手动实现</td></tr><tr><td><strong>跨浏览器兼容</strong></td><td>内置处理</td><td>需手动适配</td></tr><tr><td><strong><code>this</code> 指向</strong></td><td>类组件中需手动绑定</td><td>默认指向触发元素</td></tr></tbody></table><p>React 事件系统通过抽象和优化，提供了更高效、一致的事件处理方式，避免了直接操作 DOM 的繁琐和兼容性问题。</p></details><h2 id="简述-react-batchupdate-机制" tabindex="-1">简述 React batchUpdate 机制 <a class="header-anchor" href="#简述-react-batchupdate-机制" aria-label="Permalink to &quot;简述 React batchUpdate 机制&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 的 <strong>batchUpdate（批处理更新）机制</strong> 是一种优化策略，旨在将多个状态更新合并为一次渲染，减少不必要的组件重新渲染次数，从而提高性能。</p><p><strong>核心机制</strong></p><ol><li><p><strong>异步合并更新</strong> 当在 <strong>同一执行上下文</strong>（如同一个事件处理函数、生命周期方法或 React 合成事件）中多次调用状态更新（如 <code>setState</code>、<code>useState</code> 的 <code>setter</code> 函数），React 不会立即触发渲染，而是将多个更新收集到一个队列中，最终合并为一次更新，统一计算新状态并渲染。</p></li><li><p><strong>更新队列</strong> React 内部维护一个更新队列。在触发更新的代码块中，所有状态变更会被暂存到队列，直到代码执行完毕，React 才会一次性处理队列中的所有更新，生成新的虚拟 DOM，并通过 Diff 算法高效更新真实 DOM。</p></li></ol><p><strong>触发批处理的场景</strong></p><ol><li><p><strong>React 合成事件</strong> 如 <code>onClick</code>、<code>onChange</code> 等事件处理函数中的多次状态更新会自动批处理。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新入队</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新入队</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 最终合并为一次渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>React 生命周期函数</strong> 在 <code>componentDidMount</code>、<code>componentDidUpdate</code> 等生命周期方法中的更新会被批处理。</p></li><li><p><strong>React 18+ 的自动批处理增强</strong> React 18 引入 <code>createRoot</code> 后，即使在异步操作（如 <code>setTimeout</code>、<code>Promise</code>、原生事件回调）中的更新也会自动批处理：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 18 中自动批处理</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 合并为一次渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ol><p><strong>绕过批处理的场景</strong></p><ol><li><p><strong>React 17 及之前的异步代码</strong> 在 <code>setTimeout</code>、<code>Promise</code> 或原生事件回调中的更新默认<strong>不会</strong>批处理，每次 <code>setState</code> 触发一次渲染：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React 17 中会触发两次渲染</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 渲染一次</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 渲染第二次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li><li><p><strong>手动强制同步更新</strong> 使用 <code>flushSync</code>（React 18+）可强制立即更新，绕过批处理：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { flushSync } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flushSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 立即渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再次渲染</span></span></code></pre></div></li></ol><p><strong>设计目的</strong></p><ol><li><p><strong>性能优化</strong> 避免频繁的 DOM 操作，减少浏览器重绘和回流，提升应用性能。</p></li><li><p><strong>状态一致性</strong> 确保在同一个上下文中多次状态变更后，组件最终基于最新的状态值渲染，避免中间状态导致的 UI 不一致。</p></li></ol><p><strong>示例对比</strong></p><ul><li><p><strong>自动批处理（React 18+）</strong></p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新入队</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新入队</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 最终 count 增加 2，仅一次渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>非批处理（React 17 异步代码）</strong></p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 渲染一次</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再渲染一次</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // React 17 中触发两次渲染，count 仍为 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ul><table tabindex="0"><thead><tr><th>场景</th><th>React 17 及之前</th><th>React 18+（使用 <code>createRoot</code>）</th></tr></thead><tbody><tr><td><strong>合成事件/生命周期</strong></td><td>自动批处理</td><td>自动批处理</td></tr><tr><td><strong>异步操作</strong></td><td>不批处理</td><td>自动批处理</td></tr><tr><td><strong>原生事件回调</strong></td><td>不批处理</td><td>自动批处理</td></tr></tbody></table><p>React 的批处理机制通过合并更新减少了渲染次数，但在需要即时反馈的场景（如动画）中，可通过 <code>flushSync</code> 强制同步更新。</p></details><h2 id="简述-react-事务机制" tabindex="-1">简述 React 事务机制 <a class="header-anchor" href="#简述-react-事务机制" aria-label="Permalink to &quot;简述 React 事务机制&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 的 <strong>事务机制（Transaction）</strong> 是早期版本（React 16 之前）中用于 <strong>批量处理更新</strong> 和 <strong>管理副作用</strong> 的核心设计模式，其核心思想是通过“包装”操作流程，确保在更新过程中执行特定的前置和后置逻辑（如生命周期钩子、事件监听等）。随着 React Fiber 架构的引入，事务机制逐渐被更灵活的调度系统取代。</p><p><strong>核心概念</strong></p><ol><li><p><strong>事务的定义</strong> 事务是一个包含 <strong>初始化阶段</strong>、<strong>执行阶段</strong> 和 <strong>收尾阶段</strong> 的流程控制单元。每个事务通过 <code>Transaction</code> 类实现，提供 <code>initialize</code> 和 <code>close</code> 方法，用于在操作前后插入逻辑。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyTransaction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  initialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 前置操作（如记录状态） */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 后置操作（如触发更新） */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>包装函数</strong> 事务通过 <code>perform</code> 方法执行目标函数，将其包裹在事务的生命周期中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 核心逻辑（如调用 setState） */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyTransaction.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myAction)</span></span></code></pre></div></li></ol><p><strong>在 React 中的应用场景</strong></p><ol><li><p><strong>批量更新（Batching Updates）</strong> 在事件处理或生命周期方法中，多次调用 <code>setState</code> 会被事务合并为一次更新。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 事务包裹下的多次 setState 合并为一次渲染</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>生命周期钩子的触发</strong> 在组件挂载或更新时，事务确保 <code>componentWillMount</code>、<code>componentDidMount</code> 等钩子在正确时机执行。</p></li><li><p><strong>事件系统的委托</strong> 合成事件（如 <code>onClick</code>）的处理逻辑通过事务绑定和解绑，确保事件监听的一致性和性能优化。</p></li></ol><p><strong>事务的工作流程</strong></p><ol><li><strong>初始化阶段</strong> 执行所有事务的 <code>initialize</code> 方法（如记录当前 DOM 状态、锁定事件监听）。</li><li><strong>执行目标函数</strong> 运行核心逻辑（如用户定义的 <code>setState</code> 或事件处理函数）。</li><li><strong>收尾阶段</strong> 执行所有事务的 <code>close</code> 方法（如对比 DOM 变化、触发更新、解锁事件）。</li></ol><p><strong>事务机制的局限性</strong></p><ol><li><strong>同步阻塞</strong> 事务的执行是同步且不可中断的，无法支持异步优先级调度（如 Concurrent Mode 的时间切片）。</li><li><strong>复杂性高</strong> 事务的嵌套和组合逻辑复杂，难以维护和扩展。</li></ol><p><strong>Fiber 架构的演进</strong> React 16 引入的 <strong>Fiber 架构</strong> 替代了事务机制，核心改进包括：</p><ol><li><strong>异步可中断更新</strong> 通过 Fiber 节点的链表结构，支持暂停、恢复和优先级调度。</li><li><strong>更细粒度的控制</strong> 将渲染拆分为多个阶段（如 <code>render</code> 和 <code>commit</code>），副作用管理更灵活。</li><li><strong>替代批量更新策略</strong> 使用调度器（Scheduler）和优先级队列实现更高效的批处理（如 React 18 的自动批处理）。</li></ol><table tabindex="0"><thead><tr><th>特性</th><th>事务机制（React &lt;16）</th><th>Fiber 架构（React 16+）</th></tr></thead><tbody><tr><td><strong>更新方式</strong></td><td>同步批量更新</td><td>异步可中断、优先级调度</td></tr><tr><td><strong>副作用管理</strong></td><td>通过事务生命周期控制</td><td>通过 Effect Hook、提交阶段处理</td></tr><tr><td><strong>复杂度</strong></td><td>高（嵌套事务逻辑复杂）</td><td>高（但更模块化和可扩展）</td></tr><tr><td><strong>适用场景</strong></td><td>简单同步更新</td><td>复杂异步渲染（如动画、懒加载）</td></tr></tbody></table><p>事务机制是 React 早期实现批量更新的基石，但其同步设计无法满足现代前端应用的复杂需求。Fiber 架构通过解耦渲染过程，为 Concurrent Mode 和 Suspense 等特性奠定了基础，成为 React 高效渲染的核心。</p></details><h2 id="理解-react-concurrency-并发机制" tabindex="-1">理解 React concurrency 并发机制 <a class="header-anchor" href="#理解-react-concurrency-并发机制" aria-label="Permalink to &quot;理解 React concurrency 并发机制&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 的并发机制（Concurrency）是 React 18 引入的一项重要特性，旨在提升应用的响应性和性能。</p><p><strong>1. 什么是 React 的并发机制？</strong></p><p>React 的并发机制允许 React 在渲染过程中根据任务的优先级进行调度和中断，从而确保高优先级的更新能够及时渲染，而不会被低优先级的任务阻塞。</p><p><strong>2. 并发机制的工作原理：</strong></p><ul><li><p><strong>时间分片（Time Slicing）：</strong> React 将渲染任务拆分为多个小片段，每个片段在主线程空闲时执行。这使得浏览器可以在渲染过程中处理用户输入和其他高优先级任务，避免长时间的渲染阻塞用户交互。</p></li><li><p><strong>优先级调度（Priority Scheduling）：</strong> React 为不同的更新分配不同的优先级。高优先级的更新（如用户输入）会被优先处理，而低优先级的更新（如数据预加载）可以在空闲时处理。</p></li><li><p><strong>可中断渲染（Interruptible Rendering）：</strong> 在并发模式下，React 可以中断当前的渲染任务，处理更高优先级的任务，然后再恢复之前的渲染。这确保了应用在长时间渲染过程中仍能保持响应性。</p></li></ul><p><strong>3. 并发机制的优势：</strong></p><ul><li><p><strong>提升响应性：</strong> 通过优先处理高优先级任务，React 能够更快地响应用户输入，提升用户体验。</p></li><li><p><strong>优化性能：</strong> 将渲染任务拆分为小片段，避免长时间的渲染阻塞，提升应用的整体性能。</p></li><li><p><strong>更好的资源利用：</strong> 在主线程空闲时处理低优先级任务，充分利用系统资源。</p></li></ul><p><strong>4. 如何启用并发模式：</strong></p><p>要在 React 应用中启用并发模式，需要使用 <code>createRoot</code> API：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom/client&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./App&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;)</span></span></code></pre></div><p>在并发模式下，React 会自动根据任务的优先级进行调度和渲染。</p></details><h2 id="react-reconciliation-协调的过程" tabindex="-1">React reconciliation 协调的过程 <a class="header-anchor" href="#react-reconciliation-协调的过程" aria-label="Permalink to &quot;React reconciliation 协调的过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 的 <strong>协调（Reconciliation）</strong> 是用于高效更新 UI 的核心算法。当组件状态或属性变化时，React 会通过对比新旧虚拟 DOM（Virtual DOM）树，找出最小化的差异并应用更新。以下是协调过程的详细步骤：</p><ol><li><strong>生成虚拟 DOM 树</strong></li></ol><ul><li>当组件状态或属性变化时，React 会重新调用组件的 <code>render</code> 方法，生成新的<strong>虚拟 DOM 树</strong>（一个轻量级的 JavaScript 对象，描述 UI 结构）。</li><li>虚拟 DOM 是实际 DOM 的抽象表示，操作成本远低于直接操作真实 DOM。</li></ul><ol start="2"><li><strong>Diffing 算法（差异对比）</strong> React 使用 <strong>Diffing 算法</strong> 比较新旧两棵虚拟 DOM 树，找出需要更新的部分。对比规则如下：</li></ol><p><strong>规则一：不同类型的元素</strong></p><ul><li>如果新旧元素的 <code>type</code> 不同（例如从 <code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>），React 会<strong>销毁旧子树</strong>，<strong>重建新子树</strong>。 <ul><li>旧组件的生命周期方法（如 <code>componentWillUnmount</code>）会被触发。</li><li>新组件的生命周期方法（如 <code>constructor</code>、<code>componentDidMount</code>）会被触发。</li></ul></li></ul><p><strong>规则二：相同类型的元素</strong></p><ul><li>如果元素的 <code>type</code> 相同（例如 <code>&lt;div className=&quot;old&quot;&gt;</code> → <code>&lt;div className=&quot;new&quot;&gt;</code>），React 会<strong>保留 DOM 节点</strong>，仅更新变化的属性。 <ul><li>对比新旧属性，仅更新差异部分（例如 <code>className</code>）。</li><li>组件实例保持不变，生命周期方法（如 <code>componentDidUpdate</code>）会被触发。</li></ul></li></ul><p><strong>规则三：递归处理子节点</strong></p><ul><li>对于子节点的对比，React 默认使用<strong>逐层递归</strong>的方式。</li><li><strong>列表对比优化</strong>： <ul><li>当子元素是列表（例如通过 <code>map</code> 生成的元素）时，React 需要唯一 <code>key</code> 来标识元素，以高效复用 DOM 节点。</li><li>若未提供 <code>key</code>，React 会按顺序对比子节点，可能导致性能下降或状态错误（例如列表顺序变化时）。</li></ul></li></ul><ol start="3"><li><strong>更新真实 DOM</strong></li></ol><ul><li>通过 Diffing 算法找出差异后，React 将生成一系列<strong>最小化的 DOM 操作指令</strong>（例如 <code>updateTextContent</code>、<code>replaceChild</code>）。</li><li>这些指令会被批量应用到真实 DOM 上，以减少重绘和重排的次数，提高性能。</li></ul><ol start="4"><li><strong>协调的优化策略</strong></li></ol><ul><li><strong>Key 的作用</strong>：为列表元素提供唯一的 <code>key</code>，帮助 React 识别元素的移动、添加或删除，避免不必要的重建。</li><li><strong>批量更新（Batching）</strong>：React 会将多个状态更新合并为一次渲染，减少重复计算。</li><li><strong>Fiber 架构</strong>（React 16+）： <ul><li>将协调过程拆分为可中断的“工作单元”（Fiber 节点），允许高优先级任务（如动画）优先处理。</li><li>支持异步渲染（Concurrent Mode），避免长时间阻塞主线程。</li></ul></li></ul></details><h2 id="react-组件渲染和更新的全过程" tabindex="-1">React 组件渲染和更新的全过程 <a class="header-anchor" href="#react-组件渲染和更新的全过程" aria-label="Permalink to &quot;React 组件渲染和更新的全过程&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>React 组件的渲染和更新过程涉及多个阶段，包括 <strong>初始化、渲染、协调、提交、清理</strong> 等。以下是 React 组件渲染和更新的全过程，结合源码逻辑和关键步骤进行详细分析。</p><hr><p><strong>1. 整体流程概述</strong> React 的渲染和更新过程可以分为以下几个阶段：</p><ol><li><strong>初始化阶段</strong>：创建 Fiber 树和 Hooks 链表。</li><li><strong>渲染阶段</strong>：生成新的虚拟 DOM（Fiber 树）。</li><li><strong>协调阶段</strong>：对比新旧 Fiber 树，找出需要更新的部分。</li><li><strong>提交阶段</strong>：将更新应用到真实 DOM。</li><li><strong>清理阶段</strong>：重置全局变量，准备下一次更新。</li></ol><p><strong>2. 详细流程分析</strong></p><p><strong>（1）初始化阶段</strong></p><ul><li><strong>触发条件</strong>：组件首次渲染或状态/属性更新。</li><li><strong>关键函数</strong>：<code>render</code>、<code>createRoot</code>、<code>scheduleUpdateOnFiber</code>。</li><li><strong>逻辑</strong>： <ol><li>通过 <code>ReactDOM.render</code> 或 <code>createRoot</code> 初始化应用。</li><li>创建根 Fiber 节点（<code>HostRoot</code>）。</li><li>调用 <code>scheduleUpdateOnFiber</code>，将更新任务加入调度队列。</li></ol></li></ul><p><strong>（2）渲染阶段</strong></p><ul><li><strong>触发条件</strong>：调度器开始执行任务。</li><li><strong>关键函数</strong>：<code>performSyncWorkOnRoot</code>、<code>beginWork</code>、<code>renderWithHooks</code>。</li><li><strong>逻辑</strong>： <ol><li>调用 <code>performSyncWorkOnRoot</code>，开始渲染任务。</li><li>调用 <code>beginWork</code>，递归处理 Fiber 节点。</li><li>对于函数组件，调用 <code>renderWithHooks</code>，执行组件函数并生成新的 Hooks 链表。</li><li>对于类组件，调用 <code>instance.render</code>，生成新的虚拟 DOM。</li><li>对于 Host 组件（如 <code>div</code>），生成对应的 DOM 节点。</li></ol></li></ul><p><strong>（3）协调阶段</strong></p><ul><li><strong>触发条件</strong>：新的虚拟 DOM 生成后。</li><li><strong>关键函数</strong>：<code>reconcileChildren</code>、<code>diff</code>。</li><li><strong>逻辑</strong>： <ol><li>调用 <code>reconcileChildren</code>，对比新旧 Fiber 节点。</li><li>根据 <code>diff</code> 算法，找出需要更新的节点。</li><li>为需要更新的节点打上 <code>Placement</code>、<code>Update</code>、<code>Deletion</code> 等标记。</li></ol></li></ul><p><strong>（4）提交阶段</strong></p><ul><li><strong>触发条件</strong>：协调阶段完成后。</li><li><strong>关键函数</strong>：<code>commitRoot</code>、<code>commitWork</code>。</li><li><strong>逻辑</strong>： <ol><li>调用 <code>commitRoot</code>，开始提交更新。</li><li>调用 <code>commitWork</code>，递归处理 Fiber 节点。</li><li>根据节点的标记，执行 DOM 操作（如插入、更新、删除）。</li><li>调用生命周期钩子（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>）。</li></ol></li></ul><p><strong>（5）清理阶段</strong></p><ul><li><strong>触发条件</strong>：提交阶段完成后。</li><li><strong>关键函数</strong>：<code>resetHooks</code>、<code>resetContext</code>。</li><li><strong>逻辑</strong>： <ol><li>重置全局变量（如 <code>currentlyRenderingFiber</code>、<code>currentHook</code>）。</li><li>清理上下文和副作用。</li><li>准备下一次更新。</li></ol></li></ul></details><h2 id="为何-hooks-不能放在条件或循环之内" tabindex="-1">为何 Hooks 不能放在条件或循环之内？ <a class="header-anchor" href="#为何-hooks-不能放在条件或循环之内" aria-label="Permalink to &quot;为何 Hooks 不能放在条件或循环之内？&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>一个组件中的 hook 会以链表的形式串起来， FiberNode 的 memoizedState 中保存了 Hooks 链表中的第一个 Hook。</p><p>在更新时，会复用之前的 Hook，如果通过了条件或循环语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks状态和当前 hooks 不一致的问题。</p></details><h2 id="useeffect-的底层是如何实现的-美团" tabindex="-1">useEffect 的底层是如何实现的（美团） <a class="header-anchor" href="#useeffect-的底层是如何实现的-美团" aria-label="Permalink to &quot;useEffect 的底层是如何实现的（美团）&quot;">​</a></h2><p>参考答案</p><details class="details custom-block"><summary>Details</summary><p>useEffect 是 React 用于管理副作用的 Hook，它在 commit 阶段 统一执行，确保副作用不会影响渲染。</p><p>在 React 源码中，useEffect 通过 Fiber 机制 在 commit 阶段 进行处理：</p><p><strong>(1) useEffect 存储在 Fiber 节点上</strong></p><p>React 组件是通过 Fiber 数据结构 组织的，每个 useEffect 都会存储在 fiber.updateQueue 中。</p><p><strong>(2) useEffect 何时执行</strong></p><p>React 组件更新后，React 在 commit 阶段 统一遍历 effect 队列，并执行 useEffect 副作用。</p><p>React 使用 <code>useEffectEvent()</code> 注册 effect，在 commitLayoutEffect 之后，异步执行 useEffect，避免阻塞 UI 渲染。</p><p><strong>(3) useEffect 依赖变化的处理</strong></p><p>依赖数组的比较使用 <code>Object.is()</code>，只有依赖变化时才重新执行 useEffect。</p><p>在更新阶段，React 遍历旧 effect，并先执行清理函数，然后再执行新的 effect。</p><p><strong>简化的 useEffect 实现如下：</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> currentEffect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCurrentEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取当前 Fiber 节点的 Effect</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dependenciesChanged</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentEffect.dependencies, dependencies)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cleanupPreviousEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentEffect) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先执行上次 effect 的清理函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cleanup</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行 useEffect 传入的回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    currentEffect.dependencies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencies</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    currentEffect.cleanup </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cleanup </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存储清理函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>相比 useLayoutEffect，useEffect 是 异步执行，不会阻塞 UI 渲染。</p></details>`,48)]))}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
